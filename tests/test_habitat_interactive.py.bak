#!/usr/bin/env python3
"""
Habitatç¯å¢ƒäº¤äº’å¼æµ‹è¯•
æ”¯æŒé”®ç›˜é¼ æ ‡æ§åˆ¶ï¼Œå¯è§†åŒ–ç•Œé¢ï¼Œç”¨äºäººå·¥åˆ¤æ–­åœºæ™¯è´¨é‡

æ§åˆ¶è¯´æ˜:
- W/â†‘: å‰è¿› (move_forward)
- A/â†: å·¦è½¬ (turn_left)
- D/â†’: å³è½¬ (turn_right)
- S/â†“: åé€€ (move_backward)
- R: é‡ç½®åœºæ™¯
- Q/ESC: é€€å‡º
- SPACE: æš‚åœ/ç»§ç»­
- 1: æ˜¾ç¤ºå‰ç½®æ‘„åƒå¤´
- 2: æ˜¾ç¤ºåç½®æ‘„åƒå¤´
- 3: æ˜¾ç¤ºåŒæ‘„åƒå¤´ (é»˜è®¤)
"""

import sys
import os
from pathlib import Path

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°è·¯å¾„
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

import cv2
import numpy as np
import logging
from datetime import datetime
from typing import Dict, Any, Optional, Tuple
import json

# å¯¼å…¥é¡¹ç›®æ¨¡å—
from src.config_loader import UnifiedConfigLoader
from src.habitat_integration import EnvironmentFactory


class HabitatInteractiveTester:
    """Habitatç¯å¢ƒäº¤äº’å¼æµ‹è¯•å™¨"""

    def __init__(self, config_dir: str = "configs"):
        """åˆå§‹åŒ–æµ‹è¯•å™¨

        Args:
            config_dir: é…ç½®æ–‡ä»¶ç›®å½•
        """
        self.config_dir = Path(config_dir)
        self.logger = self._setup_logger()

        # åŠ è½½é…ç½®
        self.loader = UnifiedConfigLoader(config_dir=str(self.config_dir))
        self.env_config = self.loader.load_environment_config()

        # åˆ›å»ºç¯å¢ƒ
        self.env = None
        self.env_type = None

        # å¯è§†åŒ–çŠ¶æ€
        self.paused = False
        self.camera_mode = 3  # 1=å‰ç½®, 2=åç½®, 3=åŒæ‘„
        self.show_info = True

        # ç»Ÿè®¡ä¿¡æ¯
        self.total_steps = 0
        self.action_counts = {
            "move_forward": 0,
            "move_backward": 0,
            "turn_left": 0,
            "turn_right": 0,
        }

        # çª—å£åç§°
        self.window_name = "Habitat Interactive Test - Press Q to Quit"

        self.logger.info("âœ… Habitatäº¤äº’å¼æµ‹è¯•å™¨åˆå§‹åŒ–å®Œæˆ")
        self.logger.info(f"ğŸ“‚ é…ç½®ç›®å½•: {self.config_dir}")
        self.logger.info(f"ğŸ—ºï¸  åœºæ™¯æ–‡ä»¶: {self.env_config.get('scene', {}).get('path')}")
        self.logger.info(
            f"ğŸ¤– æœºå™¨äººURDF: {self.env_config.get('robot', {}).get('urdf_path')}"
        )

    def _setup_logger(self) -> logging.Logger:
        """è®¾ç½®æ—¥å¿—è®°å½•å™¨"""
        logger = logging.getLogger("HabitatInteractiveTest")
        logger.setLevel(logging.INFO)

        # æ§åˆ¶å°å¤„ç†å™¨
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S",
        )
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)

        return logger

    def create_environment(self) -> bool:
        """åˆ›å»ºHabitatç¯å¢ƒ

        Returns:
            åˆ›å»ºæ˜¯å¦æˆåŠŸ
        """
        try:
            self.logger.info("ğŸ”„ æ­£åœ¨åˆ›å»ºHabitatç¯å¢ƒ...")

            # ä½¿ç”¨EnvironmentFactoryåˆ›å»ºç¯å¢ƒ
            factory = EnvironmentFactory(logger=self.logger)

            # ä»ç¯å¢ƒé…ç½®æ„å»ºæ‰€éœ€çš„é…ç½®å­—å…¸
            scene_config = self.env_config.get("scene", {})
            robot_config = self.env_config.get("robot", {})
            sensor_config = self.env_config.get("sensors", {})
            action_config = self.env_config.get("actions", {})
            agent_config = self.env_config.get("agent", {})
            physics_config = self.env_config.get("physics", {})

            # æ„å»ºç¯å¢ƒé…ç½®
            config = {
                "scene_path": scene_config.get("path", ""),
                "agent_config": {
                    "height": agent_config.get("height", 0.55),
                    "radius": agent_config.get("radius", 0.28),
                    "enable_front_camera": sensor_config.get("front_camera", {}).get(
                        "enabled", True
                    ),
                    "enable_back_camera": sensor_config.get("back_camera", {}).get(
                        "enabled", True
                    ),
                    "front_camera_resolution": sensor_config.get(
                        "front_camera", {}
                    ).get("resolution", [720, 1280]),
                    "front_camera_hfov": sensor_config.get("front_camera", {}).get(
                        "hfov", 102.0
                    ),
                    "back_camera_resolution": sensor_config.get("back_camera", {}).get(
                        "resolution", [480, 640]
                    ),
                    "back_camera_hfov": sensor_config.get("back_camera", {}).get(
                        "hfov", 90.0
                    ),
                    "back_camera_position": sensor_config.get("back_camera", {}).get(
                        "position", [-0.3, 0.3, 0.0]
                    ),
                    "back_camera_orientation": sensor_config.get("back_camera", {}).get(
                        "orientation", [-0.3, 0.0, 0.0]
                    ),
                    "action_forward_amount": action_config.get("move_forward", {}).get(
                        "amount", 0.25
                    ),
                    "action_turn_left_amount": action_config.get("turn_left", {}).get(
                        "amount", 10.0
                    ),
                    "action_turn_right_amount": action_config.get("turn_right", {}).get(
                        "amount", 10.0
                    ),
                },
                "sim_config": {
                    "enable_physics": physics_config.get("enabled", True),
                    "physics_config_file": "data/default.physics_config.json",
                },
                "env_config": self.env_config,  # ä¼ é€’å®Œæ•´çš„ç¯å¢ƒé…ç½®
                "enable_visualization": True,  # å¯ç”¨å¯è§†åŒ–
            }

            self.env, self.env_type = factory.create_environment(config)

            if self.env is None:
                self.logger.error("âŒ ç¯å¢ƒåˆ›å»ºå¤±è´¥")
                return False

            self.logger.info(f"âœ… ç¯å¢ƒåˆ›å»ºæˆåŠŸ: {self.env_type}")

            # é‡ç½®ç¯å¢ƒ
            obs = self.env.reset()
            self.logger.info(f"âœ… ç¯å¢ƒå·²é‡ç½®")
            self.logger.info(f"ğŸ“Š è§‚æµ‹é”®: {list(obs.keys())}")

            return True

        except Exception as e:
            self.logger.error(f"âŒ ç¯å¢ƒåˆ›å»ºå¤±è´¥: {e}")
            import traceback

            self.logger.error(traceback.format_exc())
            return False

    def _process_keyboard_input(self, key: int) -> Optional[str]:
        """å¤„ç†é”®ç›˜è¾“å…¥

        Args:
            key: OpenCVé”®ç 

        Returns:
            åŠ¨ä½œåç§°ï¼Œå¦‚æœé€€å‡ºè¿”å›None
        """
        action = None

        # é€€å‡ºé”®
        if key in [ord("q"), ord("Q"), 27]:  # Qæˆ–ESC
            return "QUIT"

        # é‡ç½®
        elif key in [ord("r"), ord("R")]:
            return "RESET"

        # æš‚åœ/ç»§ç»­
        elif key == 32:  # SPACE
            self.paused = not self.paused
            status = "æš‚åœ" if self.paused else "ç»§ç»­"
            self.logger.info(f"â¸ï¸  {status}")
            return "PAUSE"

        # æ‘„åƒå¤´æ¨¡å¼åˆ‡æ¢
        elif key == ord("1"):
            self.camera_mode = 1
            self.logger.info("ğŸ“· åˆ‡æ¢åˆ°å‰ç½®æ‘„åƒå¤´")
            return "CAMERA"
        elif key == ord("2"):
            self.camera_mode = 2
            self.logger.info("ğŸ“· åˆ‡æ¢åˆ°åç½®æ‘„åƒå¤´")
            return "CAMERA"
        elif key == ord("3"):
            self.camera_mode = 3
            self.logger.info("ğŸ“· åˆ‡æ¢åˆ°åŒæ‘„åƒå¤´")
            return "CAMERA"

        # ç§»åŠ¨æ§åˆ¶ (ä¸VLMåŠ¨ä½œä¸€è‡´)
        elif key in [ord("w"), ord("W"), 82]:  # Wæˆ–â†‘
            action = "move_forward"
        elif key in [ord("s"), ord("S"), 84]:  # Sæˆ–â†“
            action = "move_backward"
        elif key in [ord("a"), ord("A"), 81]:  # Aæˆ–â†
            action = "turn_left"
        elif key in [ord("d"), ord("D"), 83]:  # Dæˆ–â†’
            action = "turn_right"

        return action

    def _create_visualization(self, obs: Dict[str, Any]) -> np.ndarray:
        """åˆ›å»ºå¯è§†åŒ–å›¾åƒ

        Args:
            obs: è§‚æµ‹æ•°æ®

        Returns:
            å¯è§†åŒ–å›¾åƒ
        """
        # æå–RGBå›¾åƒ
        rgb_front = obs.get("rgb_front")
        rgb_back = obs.get("rgb_back")

        # ç¡®ä¿å›¾åƒå­˜åœ¨ä¸”æ ¼å¼æ­£ç¡®
        if rgb_front is None:
            rgb_front = np.zeros((720, 1280, 3), dtype=np.uint8)
        if rgb_back is None:
            rgb_back = np.zeros((480, 640, 3), dtype=np.uint8)

        # è½¬æ¢ä¸ºuint8
        if rgb_front.dtype != np.uint8:
            rgb_front = (rgb_front * 255).astype(np.uint8)
        if rgb_back.dtype != np.uint8:
            rgb_back = (rgb_back * 255).astype(np.uint8)

        # æ ¹æ®æ‘„åƒå¤´æ¨¡å¼é€‰æ‹©æ˜¾ç¤º
        if self.camera_mode == 1:
            # ä»…å‰ç½®
            display = rgb_front.copy()
        elif self.camera_mode == 2:
            # ä»…åç½®ï¼ˆæ”¾å¤§åˆ°ä¸å‰ç½®ç›¸åŒé«˜åº¦ï¼‰
            scale = rgb_front.shape[0] / rgb_back.shape[0]
            new_width = int(rgb_back.shape[1] * scale)
            display = cv2.resize(rgb_back, (new_width, rgb_front.shape[0]))
        else:
            # åŒæ‘„ï¼ˆä¸Šä¸‹æ‹¼æ¥ï¼‰
            # å°†åç½®æ‘„åƒå¤´å®½åº¦è°ƒæ•´åˆ°ä¸å‰ç½®ç›¸åŒ
            back_resized = cv2.resize(rgb_back, (rgb_front.shape[1], rgb_back.shape[0]))
            display = np.vstack([rgb_front, back_resized])

        # æ·»åŠ ä¿¡æ¯è¦†ç›–å±‚
        if self.show_info:
            display = self._add_info_overlay(display, obs)

        return display

    def _add_info_overlay(self, img: np.ndarray, obs: Dict[str, Any]) -> np.ndarray:
        """åœ¨å›¾åƒä¸Šæ·»åŠ ä¿¡æ¯è¦†ç›–å±‚

        Args:
            img: åŸå§‹å›¾åƒ
            obs: è§‚æµ‹æ•°æ®

        Returns:
            æ·»åŠ ä¿¡æ¯åçš„å›¾åƒ
        """
        overlay = img.copy()

        # æå–ä½ç½®ä¿¡æ¯
        agent_pos = obs.get("agent_pos", [0, 0, 0])
        agent_rot = obs.get("agent_rot", [0, 0, 0, 1])

        # è®¡ç®—æœå‘è§’åº¦ (ä»å››å…ƒæ•°)
        if len(agent_rot) == 4:
            qw, qx, qy, qz = agent_rot
            # è®¡ç®—yawè§’åº¦
            yaw = np.arctan2(2.0 * (qw * qz + qx * qy), 1.0 - 2.0 * (qy * qy + qz * qz))
            yaw_deg = np.degrees(yaw)
        else:
            yaw_deg = 0.0

        # åŠé€æ˜èƒŒæ™¯
        overlay_bg = overlay.copy()
        cv2.rectangle(overlay_bg, (10, 10), (500, 200), (0, 0, 0), -1)
        cv2.addWeighted(overlay_bg, 0.6, overlay, 0.4, 0, overlay)

        # æ–‡å­—ä¿¡æ¯
        font = cv2.FONT_HERSHEY_SIMPLEX
        font_scale = 0.6
        font_thickness = 2
        color = (255, 255, 255)

        y_offset = 35
        line_height = 25

        # æ˜¾ç¤ºä¿¡æ¯
        texts = [
            f"Steps: {self.total_steps}",
            f"Position: ({agent_pos[0]:.2f}, {agent_pos[1]:.2f}, {agent_pos[2]:.2f})",
            f"Rotation: {yaw_deg:.1f} deg",
            f"Camera: {'Front' if self.camera_mode == 1 else 'Back' if self.camera_mode == 2 else 'Dual'}",
            f"Status: {'PAUSED' if self.paused else 'RUNNING'}",
        ]

        for i, text in enumerate(texts):
            cv2.putText(
                overlay,
                text,
                (20, y_offset + i * line_height),
                font,
                font_scale,
                color,
                font_thickness,
            )

        # æ˜¾ç¤ºåŠ¨ä½œç»Ÿè®¡ï¼ˆå³ä¸Šè§’ï¼‰
        action_y = 35
        cv2.rectangle(
            overlay, (img.shape[1] - 260, 10), (img.shape[1] - 10, 160), (0, 0, 0), -1
        )

        action_texts = [
            "Action Counts:",
            f"Forward: {self.action_counts['move_forward']}",
            f"Backward: {self.action_counts['move_backward']}",
            f"Left: {self.action_counts['turn_left']}",
            f"Right: {self.action_counts['turn_right']}",
        ]

        for i, text in enumerate(action_texts):
            cv2.putText(
                overlay,
                text,
                (img.shape[1] - 250, action_y + i * line_height),
                font,
                0.5,
                color,
                1,
            )

        # æ˜¾ç¤ºæ§åˆ¶è¯´æ˜ï¼ˆåº•éƒ¨ï¼‰
        help_y = img.shape[0] - 100
        cv2.rectangle(
            overlay,
            (10, help_y - 30),
            (img.shape[1] - 10, img.shape[0] - 10),
            (0, 0, 0),
            -1,
        )

        help_texts = [
            "Controls: W/â†‘=Forward  S/â†“=Backward  A/â†=TurnLeft  D/â†’=TurnRight",
            "R=Reset  SPACE=Pause  1/2/3=Camera  Q/ESC=Quit",
        ]

        for i, text in enumerate(help_texts):
            cv2.putText(overlay, text, (20, help_y + i * 25), font, 0.5, (0, 255, 0), 1)

        return overlay

    def run(self):
        """è¿è¡Œäº¤äº’å¼æµ‹è¯•"""
        # åˆ›å»ºç¯å¢ƒ
        if not self.create_environment():
            self.logger.error("âŒ æ— æ³•åˆ›å»ºç¯å¢ƒï¼Œæµ‹è¯•ç»ˆæ­¢")
            return

        # åˆ›å»ºçª—å£
        cv2.namedWindow(self.window_name, cv2.WINDOW_NORMAL)
        cv2.resizeWindow(self.window_name, 1280, 960)

        self.logger.info("\n" + "=" * 60)
        self.logger.info("ğŸ® äº¤äº’å¼æµ‹è¯•å¼€å§‹")
        self.logger.info("=" * 60)
        self.logger.info("æ§åˆ¶è¯´æ˜:")
        self.logger.info("  W/â†‘ : å‰è¿› (move_forward)")
        self.logger.info("  S/â†“ : åé€€ (move_backward)")
        self.logger.info("  A/â† : å·¦è½¬ (turn_left)")
        self.logger.info("  D/â†’ : å³è½¬ (turn_right)")
        self.logger.info("  R   : é‡ç½®åœºæ™¯")
        self.logger.info("  SPACE: æš‚åœ/ç»§ç»­")
        self.logger.info("  1/2/3: åˆ‡æ¢æ‘„åƒå¤´è§†å›¾")
        self.logger.info("  Q/ESC: é€€å‡º")
        self.logger.info("=" * 60 + "\n")

        # è·å–åˆå§‹è§‚æµ‹
        obs = self.env.reset()

        running = True
        while running:
            # æ˜¾ç¤ºå½“å‰çŠ¶æ€
            if not self.paused:
                display_img = self._create_visualization(obs)
                cv2.imshow(
                    self.window_name, cv2.cvtColor(display_img, cv2.COLOR_RGB2BGR)
                )

            # ç­‰å¾…é”®ç›˜è¾“å…¥ (30fps)
            key = cv2.waitKey(33)

            if key == -1:
                continue

            # å¤„ç†è¾“å…¥
            action = self._process_keyboard_input(key)

            if action == "QUIT":
                self.logger.info("ğŸ‘‹ é€€å‡ºæµ‹è¯•")
                running = False

            elif action == "RESET":
                self.logger.info("ğŸ”„ é‡ç½®ç¯å¢ƒ")
                obs = self.env.reset()
                self.total_steps = 0
                self.action_counts = {k: 0 for k in self.action_counts}

            elif action == "PAUSE" or action == "CAMERA":
                # è¿™äº›å·²ç»åœ¨_process_keyboard_inputä¸­å¤„ç†
                pass

            elif action and action in [
                "move_forward",
                "move_backward",
                "turn_left",
                "turn_right",
            ]:
                if not self.paused:
                    # æ‰§è¡ŒåŠ¨ä½œ
                    obs, info = self.env.step(action)
                    self.total_steps += 1
                    self.action_counts[action] += 1

                    # è®°å½•è¯¦ç»†ä¿¡æ¯
                    agent_pos = obs.get("agent_pos", [0, 0, 0])
                    self.logger.info(
                        f"ğŸ® æ­¥éª¤ {self.total_steps}: {action:15s} | "
                        f"ä½ç½®: ({agent_pos[0]:6.2f}, {agent_pos[1]:6.2f}, {agent_pos[2]:6.2f})"
                    )

        # æ¸…ç†
        cv2.destroyAllWindows()
        if self.env:
            self.env.close()

        # æ˜¾ç¤ºç»Ÿè®¡
        self.logger.info("\n" + "=" * 60)
        self.logger.info("ğŸ“Š æµ‹è¯•ç»Ÿè®¡")
        self.logger.info("=" * 60)
        self.logger.info(f"æ€»æ­¥æ•°: {self.total_steps}")
        self.logger.info(f"å‰è¿›: {self.action_counts['move_forward']}")
        self.logger.info(f"åé€€: {self.action_counts['move_backward']}")
        self.logger.info(f"å·¦è½¬: {self.action_counts['turn_left']}")
        self.logger.info(f"å³è½¬: {self.action_counts['turn_right']}")
        self.logger.info("=" * 60)
        self.logger.info("âœ… æµ‹è¯•å®Œæˆ")


def main():
    """ä¸»å‡½æ•°"""
    print("\n" + "=" * 70)
    print("Habitatç¯å¢ƒäº¤äº’å¼æµ‹è¯•")
    print("=" * 70)
    print("è¯´æ˜: æœ¬æµ‹è¯•ç”¨äºäººå·¥åˆ¤æ–­Habitatåœºæ™¯æ˜¯å¦å­˜åœ¨é—®é¢˜")
    print("      ä½¿ç”¨é”®ç›˜æ§åˆ¶æœºå™¨ç‹—ï¼Œè§‚å¯Ÿåœºæ™¯æ¸²æŸ“ã€ç¢°æ’æ£€æµ‹ã€å¯¼èˆªç­‰åŠŸèƒ½")
    print("=" * 70 + "\n")

    # æ£€æŸ¥Habitatæ˜¯å¦å¯ç”¨
    try:
        import habitat_sim

        print(
            f"âœ… Habitat-sim å·²å®‰è£… (v{getattr(habitat_sim, '__version__', 'unknown')})"
        )
    except ImportError:
        print("âŒ æœªå®‰è£… Habitat-simï¼Œæ— æ³•è¿è¡Œæµ‹è¯•")
        print("   è¯·å…ˆå®‰è£…: conda install habitat-sim -c conda-forge -c aihabitat")
        return

    # åˆ›å»ºå¹¶è¿è¡Œæµ‹è¯•å™¨
    tester = HabitatInteractiveTester(config_dir="configs")

    try:
        tester.run()
    except KeyboardInterrupt:
        print("\nâš ï¸  æµ‹è¯•è¢«ç”¨æˆ·ä¸­æ–­")
    except Exception as e:
        print(f"\nâŒ æµ‹è¯•å‡ºé”™: {e}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    main()
